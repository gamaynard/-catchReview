## ---------------------------
##
## Script name: FinalLLBHaddock.R
##
## Purpose of script: To address concerns about the representativeness of 
##    different haddock subsampling proposals through simulation. Once this
##    script is complete, the analysis will be built out as an RShiny app.
##
## Author: George A. Maynard
##
## Date Created: 2020-08-19
##
## Copyright (c) George Alphonse Maynard, 2020
## Email: galphonsemaynard@gmail.com
##
## ---------------------------
##
## Notes:
##   
##
## ---------------------------

## set working directory

## ---------------------------

## Set options
options(scipen = 6, digits = 4) # eliminate scientific notation
## ---------------------------

## load up the packages we will need:  (uncomment as required)

## ---------------------------

## load up our functions into memory

## ---------------------------
## Create an empty list called "input" which will eventually be populated by the
## app user. 
input=list()

## Read in haddock length data from FY17, FY18, and FY19. The file "Lengths.csv"
## is generated by the script 
## C:\Users\George\Desktop\Autotask Workplace\Electronic Monitoring\Georges Analyses\Subsampling\v1.R
## which reads in raw data from each fishing year in different formats and 
## standardizes them. The "Lengths.csv" file is all of the discard length data 
## across species and gears for FY17-FY19. For privacy concerns, it is not
## available in the GitHub repository
lengths=read.csv("C:/Users/George/Desktop/Autotask Workplace/Electronic Monitoring/Georges Analyses/Subsampling/Lengths.csv")

## the following commands subset out only haddock discarded from longlines with
## actual lengths recorded
lengths=subset(lengths,lengths$SPECIES=="HADDOCK")
lengths=subset(lengths,lengths$GEAR=="Longline")
lengths=subset(lengths,is.na(lengths$LENGTH)==FALSE)
lengths=subset(lengths,lengths$LENGTH>5)

## for the purposes of this simulation, we will focus on a single trip
## based on data from FY17-FY19, captains fish an average of 6.9 +/- 1.8 strings
## per trip. The user will be able to specify how many strings to simulate
## between 3 and 11
input$stringsFished=7

## haddock discards per trip range from 8 to 809, with a mean of 265 (+/- 120)
## the user can specify how many discards occur on the trip, keeping in mind 
## that the number of discards must be greater than the subsample size
input$discards=265

## sample size can be between 1 and 30
input$samplesize=5

## sampling can be random or first 'n'
input$sampling='random'

## discards can be evenly distributed among strings, random,
## biased to the middle, or skewed towards one of the ends
input$DPS='random'

## sample the vector of real lengths input$discards times to create a vector of 
## discard lengths for the trip
tripDisc=sample(
  x=lengths$LENGTH,
  size=input$discards,
  replace=TRUE
  )

## assign each discard to a string based on input$DPS
strings=list()
############### For evenly distributed discards
if(input$DPS=='even'){
  for(i in seq(1,input$stringsFished-1,1)){
    strings[[i]]=sample(
      x=subset(
        seq(1,input$discards,1),
        seq(1,input$discards,1)%in%unlist(strings)==FALSE
      ),
      size=round(input$discards/input$stringsFished,0),
      replace=FALSE
    )
  }
  strings[[input$stringsFished]]=subset(
    seq(1,input$discards,1),
    seq(1,input$discards,1)%in%unlist(strings)==FALSE
  )
}

############### For skewed discards
if(input$DPS=='skewed to first' || input$DPS=='skewed to last'||input$DPS=='biased to mid'){
  a=input$discards
  for(i in seq(1,input$stringsFished-1,1)){
    if(a>0){
      b=sample(
        a,
        1
      )
      strings[[i]]=sample(
        x=subset(
          seq(1,input$discards,1),
          seq(1,input$discards,1)%in%unlist(strings)==FALSE
        ),
        size=b,
        replace=FALSE
      )
      a=a-b
    } else {
      strings[[i]]=0
    }
  }
  if(a>0){
    strings[[input$stringsFished]]=subset(
      seq(1,input$discards,1),
      seq(1,input$discards,1)%in%unlist(strings)==FALSE
    )
  } else {
    strings[[input$stringsFished]]=0
  }
  if(input$DPS=='skewed to last'){
    strings=rev(strings)
  }
  if(input$DPS=='biased to mid'){
    a=strings
    b=lengths(strings)
    strings=list()
    for(i in 1:length(a)){
      strings[[i]]=0
    }
    d=order(b)
    a=a[d]
    e=round(input$stringsFished/2,0)
    strings[[e]]=a[[length(a)]]
    a=a[-length(a)]
    g=seq(1,input$stringsFished,1)
    for(i in seq(
      1,
      round(
        length(
          subset(g,g!=e)
          )/2,0
        ),
      1)
      ){
      strings[[e-i]]=a[[length(a)]]
      a=a[-length(a)]
      strings[[e+i]]=a[[length(a)]]
      a=a[-length(a)]
    }
  }
}
############### For random discards
if(input$DPS=='random'){
  a=runif(input$stringsFished,0,1)
  b=a/sum(a)
  b=round(b*input$discards,0)
  while(sum(b)>265){
    x=sample(1:input$stringsFished,1)
    b[x]=b[x]-1
  }
  while(sum(b)<265){
    x=sample(1:input$stringsFished,1)
    b[x]=b[x]+1
  }
  for(i in 1:input$stringsFished){
    strings[[i]]=sample(
      x=subset(
        seq(1,input$discards,1),
        seq(1,input$discards,1)%in%unlist(strings)==FALSE
      ),
      size=b[i],
      replace=FALSE
    )
  }
}

## Plot the distribution of discards by string
barplot(
  height=lengths(strings),
  names.arg=seq(1,input$stringsFished,1),
  col='lightgray',
  xlab='String Number',
  ylab='Haddock Discarded'
)
## assign each fish a length
for(i in 1:length(strings)){
  if(strings[[i]][1]==0){
    strings[[i]]=NA
  } else {
    strings[[i]]=tripDisc[strings[[i]]]
  }
}

## within each string, discards can be distributed randomly, or larger discards
## could be biased to the middle, or biased towards one end, we will test all of 
## these scenarios and display the results
## Clear all strings with no discards
strings=subset(strings,is.na(strings)==FALSE)
stringsMid=strings
stringsFirst=strings
stringsLast=strings
for(i in 1:input$stringsFished){
  stringsFirst[[i]]=rev(strings[[i]][order(strings[[i]])])
  stringsLast[[i]]=strings[[i]][order(strings[[i]])]
  a=stringsMid[[i]]
  b=which(a==max(a))[1]
  d=a[b]
  e=round(length(stringsMid[[i]])/2,0)
  a=a[-b]
  a=a[order(a)]
  stringsMid[[i]][e]=d
  if(length(stringsMid[[i]])>1){
    for(j in seq(1,e,1)){
      if(length(stringsMid[[i]])>=(e+j)){
        stringsMid[[i]][e+j]=a[length(a)]
        a=a[-length(a)]
        if((e-j)>0){
          stringsMid[[i]][e-j]=a[length(a)]
          a=a[-length(a)]
        }
      }
    }
  }
}
barplot(
  strings[[which(lengths(strings)==max(lengths(strings)))]],
  col='white',
  border='white',
  ylab="Length (cm)",
  main="Randomly Distributed Lengths"
  )
for(i in 1:length(strings)){
  barplot(
    strings[[i]],
    col=i,
    add=TRUE
  )
}
barplot(
  stringsFirst[[which(lengths(stringsFirst)==max(lengths(stringsFirst)))]],
  col='white',
  border='white',
  ylab="Length (cm)",
  main="First Fish are Biggest"
)
for(i in 1:length(stringsFirst)){
  barplot(
    stringsFirst[[i]],
    col=i,
    add=TRUE
  )
}
barplot(
  stringsLast[[which(lengths(stringsLast)==max(lengths(stringsLast)))]],
  col='white',
  border='white',
  ylab="Length (cm)",
  main="Last Fish are Biggest"
)
for(i in 1:length(stringsLast)){
  barplot(
    stringsLast[[i]],
    col=i,
    add=TRUE
  )
}
barplot(
  stringsMid[[which(lengths(stringsMid)==max(lengths(stringsMid)))]],
  col='white',
  border='white',
  ylab="Length (cm)",
  main="Middle Fish are Biggest"
)
for(i in 1:length(stringsMid)){
  barplot(
    stringsMid[[i]],
    col=i,
    add=TRUE
  )
}

## Create one vector to represent the trip under the four conditions
strings=unlist(strings)
stringsFirst=unlist(strings)
stringsMid=unlist(strings)
stringsLast=unlist(strings)

## estimate a weight for each vector
estS=sample(
  strings,
  input$samplesize,
  replace=FALSE
  )
estF=sample(
  stringsFirst,
  input$samplesize,
  replace=FALSE
)
estM=sample(
  stringsMid,
  input$samplesize,
  replace=FALSE
)
estL=sample(
  stringsLast,
  input$samplesize,
  replace=FALSE
)
## Convert lengths to weights
kstrings=sum(exp(-11.8111+3.0888*log(strings))*2.204623)
kstringsFirst=sum(exp(-11.8111+3.0888*log(stringsFirst))*2.204623)
kstringsMid=sum(exp(-11.8111+3.0888*log(stringsMid))*2.204623)
kstringsLast=sum(exp(-11.8111+3.0888*log(stringsLast))*2.204623)
estS=sum(exp(-11.8111+3.0888*log(estS))*2.204623)/input$samplesize*input$discards
estF=sum(exp(-11.8111+3.0888*log(estF))*2.204623)/input$samplesize*input$discards
estM=sum(exp(-11.8111+3.0888*log(estM))*2.204623)/input$samplesize*input$discards
estL=sum(exp(-11.8111+3.0888*log(estL))*2.204623)/input$samplesize*input$discards

z=barplot(
  c(
    kstrings,
    estS,
    estF,
    estM,
    estL
  ),
  col=c(
    'darkgray',
    'purple',
    'red',
    'blue',
    'orange'
  ),
  ylab="Haddock Discard Weight (lbs)",
  main="",
  names.arg=c(
    'Known',
    'Random',
    'L First',
    'L Mid',
    'L Last'
  ),
  ylim=c(0,1.25*max(c(kstrings,estS,estF,estM,estL)))
)
abline(h=kstrings,col='black',lty=2)
text(
  x=z,
  y=0.5*max(c(kstrings,estS,estF,estM,estL)),
  labels=round(c(kstrings,estS,estF,estM,estL)-kstrings,1)
)
